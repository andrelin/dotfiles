name: Tests (WSL)
on: [push]

jobs:
  test:
    name: WSL (Ubuntu 24.04)
    runs-on: windows-latest
    env:
      CI: "true"
      SHELL_FNS: e_header src is_macos jdk mkcd gpc q mkpg
    defaults:
      run:
        shell: wsl-bash {0}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
          set-safe-directory: true

      - uses: Vampire/setup-wsl@v5
        with:
          distribution: Ubuntu-24.04
          additional-packages: curl git sudo
          wsl-conf: |
            [automount]
            options = "metadata"

      - name: Fix line endings
        run: find . -type f \( -name '*.sh' -o -name '*.zsh' -o -path '*/bin/*' \) -exec sed -i 's/\r$//' {} +

      - name: Create non-root user
        run: |
          useradd -m -s /bin/bash runner
          echo "runner ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers
          cp -r "$PWD" /home/runner/dotfiles
          chown -R runner:runner /home/runner

      - name: Configure
        shell: wsl-bash -u runner {0}
        run: |
          cd ~/dotfiles
          ln -sf "$PWD" ~/.dotfiles
          export DOTFILES=$PWD
          ./bin/dotfiles 2>&1 | tee /tmp/dotfiles_output.txt || true

          errors=0
          section="setup"
          prev=""
          while IFS= read -r line; do
            stripped="$(echo "$line" | sed $'s/\033\[[0-9;]*m//g; s/^[[:space:]]*//; s/[[:space:]]*$//')"
            [[ -z "$stripped" ]] && continue

            # Track current init script section
            if [[ "$stripped" =~ ^Sourcing\ (.+\.sh)$ ]]; then
              section="${BASH_REMATCH[1]}"
              prev=""
              continue
            fi

            # Skip known CI noise
            case "$stripped" in
              *"non-interactive mode"*) prev="$stripped"; continue ;;
              *"write error: Broken pipe"*) prev="$stripped"; continue ;;
              *"is not in your PATH"*) prev="$stripped"; continue ;;
            esac

            if echo "$stripped" | grep -qiE '\berror\b|\bfatal\b'; then
              msg="$stripped"
              [[ -n "$prev" ]] && msg="$stripped%0A  context: $prev"
              echo "::error title=$section::$msg"
              ((errors++))
            elif echo "$stripped" | grep -qiE '\bwarn\b|\bwarning\b'; then
              msg="$stripped"
              [[ -n "$prev" ]] && msg="$stripped%0A  context: $prev"
              echo "::warning title=$section::$msg"
            fi
            prev="$stripped"
          done < /tmp/dotfiles_output.txt
          exit $errors

      - name: Bash startup
        shell: wsl-bash -u runner {0}
        run: |
          cd ~/dotfiles
          export DOTFILES=$PWD
          bash --login -c '
            echo "Bash $(bash --version | head -1)"
            echo "DOTFILES=$DOTFILES"
            failed=0
            for fn in $SHELL_FNS; do
              if declare -f "$fn" >/dev/null 2>&1; then
                echo "  ✔ $fn"
              else
                echo "  ✖ $fn NOT defined"
                failed=1
              fi
            done
            exit $failed
          '

      - name: Zsh startup
        shell: wsl-bash -u runner {0}
        run: |
          cd ~/dotfiles
          if ! command -v zsh >/dev/null || [[ ! -d "$HOME/.oh-my-zsh" ]]; then
            echo "Zsh or oh-my-zsh not installed, skipping"
            exit 0
          fi
          export DOTFILES=$PWD
          SHELL=$(which zsh) zsh -c '
            source ~/.zshrc
            echo "Zsh $ZSH_VERSION"
            echo "DOTFILES=$DOTFILES"
            failed=0
            for fn in $SHELL_FNS; do
              if typeset -f "$fn" >/dev/null 2>&1; then
                echo "  ✔ $fn"
              else
                echo "  ✖ $fn NOT defined"
                failed=1
              fi
            done
            exit $failed
          '

      - name: Run tests
        shell: wsl-bash -u runner {0}
        run: |
          cd ~/dotfiles
          export DOTFILES=$PWD
          eval "$(brew shellenv 2>/dev/null)" || true
          failed=0
          for t in test/test_*.sh; do bash "$t" || failed=1; done
          exit $failed
